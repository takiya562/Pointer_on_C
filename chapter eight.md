# 8.1.1 数组名

```c
int a;
int b[10];
```

变量`a`称为标量，因为它是一个单一的值，这变量的类型是一个整树。变量`b`称为数组，它是一些值的集合。

数组名的类型是“指向`int`的常量指针”

但是数组和指针并不是一回事。数组具有确定数量的元素，而指针只是一个标量值。编译器通过数组名记住这些属性。只有当数组名在表达式中使用时，编译器才会为它产生一个指针常量。

因为是指针常量，所以我们不能修改常量的值。这个限制是合理的，指针常量所指向的是内存中数组的起始位置。在程序完成链接之后，内存中数组的位置就是固定的。

只有在两种场合下，数组名不再是指针常量：

1. `sizeof`操作符的操作数
2. 单目操作数`&`的操作数

# 8.1.2 下标引用

记住一句话：**下标引用和间接访问表达式是一样的**

所以，如下的操作在C语言中是完全合法的：

```c
int array[10];
int ap = array + 2;
int tmp = ap[0]; //合法
2[array]; //合法
*(2 + array); //与上面的表达式等价
```

# 8.1.3 指针与下标效率

```c
int array[10], a;
for (a = 0; a < 10; a += 1) {
    array[a] = 0;
}
```

对于下标表达式求值，编译器在程序中插入指令，取得`a`的值，并把它与整型数长度相乘

```c
int array[10], *ap;
for (ap = array; ap < array + 10; ap++) {
    *ap = 0;
}
```

对于指针来说，乘法运算到了`for`语句的调整部分。1这个值与整型的长度相乘，然后在于指针相加。但是这里有一个重大区别：循环每次执行时，执行乘法运算的是两个确定的值（1和4）。所以，这里的乘法只在编译时执行一次——程序现在包含一条指令，把4和指针相加。程序并不需要执行乘法运算。

> tips1: 不要为了效率上的细微差别而牺牲可读性
>
> tips2: 关键我们先要确认程序中哪些代码段占用了绝大部分运行事件，然后再把你的精力集中在这些代码上，致力于改进它们。

# 8.2.4 指向数组的指针

我们首先看两个声明

```c
int vector[10], *vp = vector;
int matrix[3][10], *mp = matrix;
```

第一个声明是合法的。它为一个整型数组分配内存，并把`vp`声明为一个指向整型的数组，并把它初始化为指向`vector`数组的第1个元素。`vector`和`vp`具有相同的类型：指向整型的指针。

第二个声明是不合法的。它正确的创建了`matrix`，并把`mp`声明为一个指向整型的指针。但是，`mp`的初始化是不正确的，因为`matrix`并不是一个指向整型的指针，而是一个指向整型数组的指针。

所以，我们应该如何声明一个指向整型数组的指针呢？

```c
int (*p)[10] = matrix;
```

上面这个声明有一点难理解。我们当作表达式求值对其进行分析。

首先执行括号内的间接访问，这里`p`是一个指针，它指向的是什么呢？

我们继续执行下标引用，所以`p`指向某种类型的数组。

在声明初始化后，`p`指向`matrix`的第一行。当我们将`p`与一个整树相加时，该整数值首先根据10个整型的长度进行调整，然后执行假发。所以实际上`p`会一行一行地在`matrix`中移动。

---------------------

那么，如果我们想要逐个地访问整型元素呢？下面的声明能够做到这一点：

```c
int *p = &matrix[0][0];
int *p = matrix[0];
```

